# close的几种情形
## 正常调用close
+ close将套接字计数减一后返回
+ 套接字的接收缓冲区中如果还有数据则丢弃,后续对套接字的write/read操作都会被拒绝
+ 如果套接字的计数被减至0,发送缓冲区中的数据将会被发送到对端,并在所有数据都发送出去后向对端发送一个终止序列[FIN]
+ 换言之,只有一个套接字的引用计数为0时才会触发四次挥手的正常终止流程,所以执行close并不严格等同于tcp连接的断开

## 设置so_linger.l_onoff=1时的close
+ close将套接字计数减一后返回
+ 套接字发送/接收缓冲区中还有数据则直接丢弃,后续对套接字的write/read操作都会被拒绝
+ 然后直接向对端发送一个rst分节,tcp状态机直接进入closed状态

## 设置so_linger.l_onoff=1,且l_linger设置为正整数时的close
+ close将阻塞l_linger秒
+ close将套接字计数减一
+ 套接字接收缓冲区中的所有数据直接丢弃,后续对套接字的write/read操作都会被拒绝
+ os内核会尝试把发送缓冲区中的所有数据都发送出去并且等待对端的确认
+ 如果在阻塞时间内能收到所有确认则向对端发送终止序列[fin]包正常关闭tcp连接[处于timewait],随后close返回
+ 如果在阻塞时间内无法发送完所有数据并且得到确认,则向对端发送一个rst分组直接关闭连接,随后close返回一个错误,EXXWOULD

## shutdown(SHUR_RD)
+ 接收缓冲区中的所有数据会被丢弃,tcp连接继续维持,随后执行read操作会被拒绝,接收到对端发送的tcp分组时会把分组中的数据丢弃,并且向对端回复一个确认,对端write时无感知
## shutdown(SHUR_WR)
+ 发送缓冲区中的所有数据会被发送出去,然后向对端发送一个正常的终止序列[fin][可以看到执行shutdown时无论套接字的引用计数是多少,都会触发断开tcp连接的操作]。随后执行write操作会被拒绝。
+ 接收缓冲区中的数据可以使用read正常读取
## shutdown(SHUR_ALL)
+ 接收缓冲区中的数据会被抛弃,发送缓冲区中的数据会被发送给对端，随后在向对端发送一个终止序列[fin]。后续对于write/read的操作都会被拒绝
+ 同样,无论套接字的引用计数是否为0,一旦调用shutdown都会直接关闭tcp连接